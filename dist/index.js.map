{"version":3,"sources":["../src/core/symbols.ts","../src/core/hooks/componentHook.ts","../src/core/components/decoratorCreator.ts","../src/core/components/ComponentArgument.ts","../src/core/components/ComponentArgumentDecorator.ts","../src/applicationCommand/ApplicationCommand.ts","../src/applicationCommand/ApplicationCommandOption.ts","../src/core/listener/index.ts","../src/core/converter/index.ts","../src/core/hooks/moduleHook.ts","../src/core/hooks/index.ts","../src/core/structures/Registry.ts","../src/core/structures/index.ts","../src/core/extensions/Extension.ts","../src/core/extensions/CTSExtension.ts","../src/applicationCommand/ApplicationCommandExtension.ts","../src/textCommand/TextCommand.ts","../src/textCommand/parameters.ts","../src/textCommand/TextCommandExtension.ts","../src/core/structures/CommandClient.ts","../src/core/components/BaseComponent.ts","../src/core/components/index.ts","../src/core/utils/errors.ts","../src/core/utils/checks.ts","../src/core/utils/decorators.ts","../src/core/utils/index.ts","../src/core/extensions/index.ts","../src/core/index.ts","../src/index.ts","../src/applicationCommand/group.ts"],"sourcesContent":["/*\r\n * File: symbols.ts\r\n *\r\n * Copyright (c) 2022-2022 pikokr\r\n *\r\n * Licensed under MIT License. Please see more defails in LICENSE file.\r\n */\r\n\r\nexport const ComponentStoreSymbol = Symbol()\r\nexport const ComponentArgStoreSymbol = Symbol()\r\nexport const ModuleHookStoreSymbol = Symbol()\r\nexport const CommandClientSymbol = Symbol()\r\nexport const ComponentHookSymbol = Symbol()\r\nexport const FilePathSymbol = Symbol()\r\n","/*\r\n * File: componentHook.ts\r\n *\r\n * Copyright (c) 2022-2022 pikokr\r\n *\r\n * Licensed under MIT License. Please see more defails in LICENSE file.\r\n */\r\n\r\nimport { Collection } from 'discord.js'\r\nimport { ComponentHookSymbol } from '../symbols'\r\n\r\nexport type ComponentHookFn = (...args: any[]) => void | Promise<void>\r\n\r\nexport type ComponentHookStore = Collection<string, ComponentHookFn[]>\r\n\r\nexport const getComponentHookStore = (target: object, property: string | symbol): ComponentHookStore => {\r\n  let data = Reflect.getMetadata(ComponentHookSymbol, target, property) as ComponentHookStore\r\n\r\n  if (!data) {\r\n    data = new Collection()\r\n    Reflect.defineMetadata(ComponentHookSymbol, data, target, property)\r\n  }\r\n\r\n  return data\r\n}\r\n\r\nexport const createComponentHook = (name: string, fn: ComponentHookFn): MethodDecorator => {\r\n  return (target, key) => {\r\n    const store = getComponentHookStore(target, key)\r\n\r\n    let hooks = store.get(name)\r\n\r\n    if (!hooks) {\r\n      hooks = []\r\n      store.set(name, hooks)\r\n    }\r\n\r\n    hooks.unshift(fn)\r\n  }\r\n}\r\n","/*\r\n * File: decoratorCreator.ts\r\n *\r\n * Copyright (c) 2022-2022 pikokr\r\n *\r\n * Licensed under MIT License. Please see more defails in LICENSE file.\r\n */\r\n\r\nimport { Collection } from 'discord.js'\r\nimport { ComponentHookStore } from '../hooks'\r\nimport { getComponentHookStore } from '../hooks/componentHook'\r\nimport { ComponentStoreSymbol } from '../symbols'\r\nimport { BaseComponent } from './BaseComponent'\r\nimport { ComponentArgumentDecorator } from './ComponentArgumentDecorator'\r\n\r\nexport type ComponentStore = Collection<string | symbol, BaseComponent>\r\nexport type ComponentArgumentStore = Collection<number, ComponentArgumentDecorator>\r\n\r\nexport const getComponentStore = (target: object): ComponentStore => {\r\n  let result: ComponentStore | null = Reflect.getMetadata(ComponentStoreSymbol, target)\r\n\r\n  if (!result) {\r\n    result = new Collection()\r\n\r\n    Reflect.defineMetadata(ComponentStoreSymbol, result, target)\r\n  }\r\n\r\n  return result\r\n}\r\n\r\nexport const getComponent = (target: object, key: string | symbol) => {\r\n  const store = getComponentStore(target)\r\n\r\n  return store.get(key)\r\n}\r\n\r\nexport const createComponentDecorator = (component: BaseComponent): MethodDecorator => {\r\n  return (target, key) => {\r\n    component._init(Reflect.get(target, key), Reflect.getMetadata('design:paramtypes', target, key))\r\n\r\n    const componentHookStore: ComponentHookStore = getComponentHookStore(target, key)\r\n\r\n    component.hooks = componentHookStore\r\n\r\n    const store = getComponentStore(target)\r\n\r\n    const decorators = getComponentArgumentStore(target, key)\r\n\r\n    decorators.forEach((x, i) => {\r\n      component.argTypes.get(i)?.decorators.push(x)\r\n    })\r\n\r\n    store.set(key, component)\r\n  }\r\n}\r\n\r\nexport const getComponentArgumentStore = (target: object, key: string | symbol): ComponentArgumentStore => {\r\n  let result: ComponentArgumentStore | null = Reflect.getMetadata(ComponentStoreSymbol, target, key)\r\n\r\n  if (!result) {\r\n    result = new Collection()\r\n\r\n    Reflect.defineMetadata(ComponentStoreSymbol, result, target, key)\r\n  }\r\n\r\n  return result\r\n}\r\n\r\nexport const createArgumentDecorator = <Options>(type: typeof ComponentArgumentDecorator<Options>) => {\r\n  return (options: Options): ParameterDecorator => {\r\n    return (target, key, idx) => {\r\n      var arg: ComponentArgumentDecorator<Options> = new type(options)\r\n\r\n      const store = getComponentArgumentStore(target, key)\r\n\r\n      store.set(idx, arg)\r\n    }\r\n  }\r\n}\r\n","/*\r\n* File: ComponentArgument.ts\r\n* \r\n* Copyright (c) 2022-2022 pikokr\r\n* \r\n* Licensed under MIT License. Please see more defails in LICENSE file.\r\n*/\r\n\r\nimport { ComponentArgumentDecorator } from './ComponentArgumentDecorator'\n\nexport class ComponentArgument {\n  decorators: ComponentArgumentDecorator[] = []\n\n  constructor(public type: unknown) {}\n}\n","/*\r\n* File: ComponentArgumentDecorator.ts\r\n* \r\n* Copyright (c) 2022-2022 pikokr\r\n* \r\n* Licensed under MIT License. Please see more defails in LICENSE file.\r\n*/\r\n\r\nimport _ from 'lodash'\n\nexport class ComponentArgumentDecorator<Options = unknown> {\n  options: Options\n\n  constructor(options: Partial<Options>) {\n    if (typeof options === 'object') {\n      this.options = _.merge(this.defaultOptions(), options)\n    } else {\n      this.options = options\n    }\n  }\n\n  defaultOptions(): Options {\n    return {} as unknown as Options\n  }\n}\n","/*\r\n * File: ApplicationCommand.ts\r\n *\r\n * Copyright (c) 2022-2022 pikokr\r\n *\r\n * Licensed under MIT License. Please see more defails in LICENSE file.\r\n */\r\n\r\nimport type { ApplicationCommandType, ChatInputApplicationCommandData, MessageApplicationCommandData, Snowflake, UserApplicationCommandData } from 'discord.js'\r\nimport { createComponentDecorator } from '../core/components/decoratorCreator'\r\nimport { BaseComponent } from '../core/components/BaseComponent'\r\nimport { SubCommandGroup, SubCommandGroupChild } from './group'\r\n\r\ntype Options = (UserApplicationCommandData | MessageApplicationCommandData | Omit<ChatInputApplicationCommandData, 'options'>) & {\r\n  type: ApplicationCommandType\r\n  guilds?: Snowflake[]\r\n}\r\n\r\nexport class ApplicationCommandComponent extends BaseComponent {\r\n  options: Options\r\n\r\n  subcommandGroup?: SubCommandGroup\r\n  subcommandGroupChild?: SubCommandGroupChild\r\n\r\n  constructor(options: UserApplicationCommandData | MessageApplicationCommandData | Omit<ChatInputApplicationCommandData, 'options'>) {\r\n    super()\r\n\r\n    this.options = options as Options\r\n  }\r\n}\r\n\r\nexport const applicationCommand = (options: Options) => createComponentDecorator(new ApplicationCommandComponent(options))\r\n\r\nexport type { Options as ApplicationCommandComponentOptions }\r\n","/*\r\n* File: ApplicationCommandOption.ts\r\n* \r\n* Copyright (c) 2022-2022 pikokr\r\n* \r\n* Licensed under MIT License. Please see more defails in LICENSE file.\r\n*/\r\n\r\nimport { APIApplicationCommandOption } from 'discord.js'\nimport { createArgumentDecorator, ComponentArgumentDecorator } from '../core'\n\ntype Options = APIApplicationCommandOption\n\nexport class ApplicationCommandOption extends ComponentArgumentDecorator<Options> {}\n\nexport const option = createArgumentDecorator(ApplicationCommandOption)\n","/*\r\n * File: index.ts\r\n *\r\n * Copyright (c) 2022-2022 pikokr\r\n *\r\n * Licensed under MIT License. Please see more defails in LICENSE file.\r\n */\r\n\r\nimport _ from 'lodash'\r\nimport { BaseComponent } from '../components/BaseComponent'\r\nimport { createComponentDecorator } from '../components/decoratorCreator'\r\n\r\ntype Options = { emitter: string; event: string }\r\n\r\ntype OptionsArg = { emitter?: string; event: string }\r\n\r\nexport class ListenerComponent extends BaseComponent {\r\n  options: Options\r\n\r\n  constructor(options: OptionsArg) {\r\n    super()\r\n\r\n    this.options = _.merge({ emitter: 'discord' }, options)\r\n  }\r\n}\r\n\r\nexport const listener = (options: OptionsArg) => createComponentDecorator(new ListenerComponent(options))\r\n\r\nexport { Options as ListenerOptions, OptionsArg as ListenerOptionsArg }\r\n","/*\r\n * File: index.ts\r\n *\r\n * Copyright (c) 2022-2022 pikokr\r\n *\r\n * Licensed under MIT License. Please see more defails in LICENSE file.\r\n */\r\n\r\nimport { BaseComponent } from '../components/BaseComponent'\r\nimport { createComponentDecorator } from '../components/decoratorCreator'\r\n\r\ntype Options = { component: unknown; type: Function; parameterless: boolean }\r\n\r\ntype OptionsArg = Omit<Options, 'parameterless'> & { parameterless?: boolean }\r\n\r\nexport class ConverterComponent extends BaseComponent {\r\n  options: Options\r\n\r\n  constructor(options: OptionsArg) {\r\n    super()\r\n    this.options = options as Options\r\n  }\r\n}\r\n\r\nexport const argConverter = (options: OptionsArg) => createComponentDecorator(new ConverterComponent(options))\r\n\r\nexport { Options as ArgumentConvertOptions, OptionsArg as ArgumentConvertOptionsArg }\r\n","/*\r\n * File: moduleHook.ts\r\n *\r\n * Copyright (c) 2022-2022 pikokr\r\n *\r\n * Licensed under MIT License. Please see more defails in LICENSE file.\r\n */\r\n\r\nimport { Collection } from 'discord.js'\r\nimport { ModuleHookStoreSymbol } from '../symbols'\r\n\r\nexport type ModuleHookStore = Collection<string, Function[]>\r\n\r\nexport const getModuleHookStore = (target: object) => {\r\n  let result: ModuleHookStore | null = Reflect.getMetadata(ModuleHookStoreSymbol, target)\r\n\r\n  if (!result) {\r\n    result = new Collection()\r\n\r\n    Reflect.defineMetadata(ModuleHookStoreSymbol, result, target)\r\n  }\r\n\r\n  return result\r\n}\r\n\r\nexport const moduleHook = (name: string): MethodDecorator => {\r\n  return (target, key) => {\r\n    const store = getModuleHookStore(target)\r\n\r\n    let v = store.get(name)\r\n\r\n    if (!v) {\r\n      v = []\r\n      store.set(name, v)\r\n    }\r\n\r\n    v.push(Reflect.get(target, key))\r\n  }\r\n}\r\n","/*\r\n * File: index.ts\r\n *\r\n * Copyright (c) 2022-2022 pikokr\r\n *\r\n * Licensed under MIT License. Please see more defails in LICENSE file.\r\n */\r\n\r\nexport * from './moduleHook'\r\nexport { createComponentHook, type ComponentHookFn } from './componentHook'\r\nexport type { ComponentHookStore } from './componentHook'\r\n","/*\r\n * File: Registry.ts\r\n *\r\n * Copyright (c) 2022-2022 pikokr\r\n *\r\n * Licensed under MIT License. Please see more defails in LICENSE file.\r\n */\r\n\r\nimport chalk from 'chalk'\r\nimport { Collection } from 'discord.js'\r\nimport EventEmitter from 'events'\r\nimport _, { result } from 'lodash'\r\nimport { Logger } from 'tslog'\r\nimport { getComponentStore } from '../components'\r\nimport { getModuleHookStore } from '../hooks'\r\nimport { ListenerComponent } from '../listener'\r\nimport { CommandClientSymbol, FilePathSymbol } from '../symbols'\r\nimport { CommandClient } from './CommandClient'\r\nimport walkSync from 'walk-sync'\r\nimport path from 'path'\r\nimport { ComponentHookFn } from '../hooks/componentHook'\r\n\r\nexport class Registry {\r\n  extensions: object[] = []\r\n\r\n  emitters: Collection<string, EventEmitter> = new Collection()\r\n\r\n  logger: Logger<unknown>\r\n\r\n  globalHooks: Record<string, ComponentHookFn[]> = {}\r\n\r\n  constructor(logger: Logger<unknown>, public client: CommandClient) {\r\n    this.logger = logger.getSubLogger({\r\n      prefix: [chalk.green('[Registry]')],\r\n    })\r\n  }\r\n\r\n  addGlobalHook(name: string, fn: ComponentHookFn) {\r\n    let hooks = this.globalHooks[name]\r\n\r\n    if (!hooks) {\r\n      hooks = []\r\n      this.globalHooks[name] = hooks\r\n    }\r\n\r\n    hooks.push(fn)\r\n  }\r\n\r\n  getComponentsWithTypeGlobal<T>(type: unknown): T[] {\r\n    const result: T[] = []\r\n\r\n    for (const ext of this.extensions) {\r\n      result.push(...this.getComponentsWithType<T>(ext, type))\r\n    }\r\n\r\n    return result\r\n  }\r\n\r\n  getComponentsWithType<T>(ext: object, type: unknown): T[] {\r\n    const componentStore = getComponentStore(ext)\r\n\r\n    return Array.from(componentStore.filter((x) => (x.constructor as unknown) === type).values() as Iterable<T>)\r\n  }\r\n\r\n  registerEventListeners(ext: object) {\r\n    const listeners = this.getComponentsWithType<ListenerComponent>(ext, ListenerComponent)\r\n\r\n    for (const listener of listeners) {\r\n      const emitter = this.emitters.get(listener.options.emitter)\r\n\r\n      if (emitter) {\r\n        const bound = listener.method.bind(ext)\r\n\r\n        Reflect.defineMetadata('bound', bound, listener)\r\n\r\n        emitter.addListener(listener.options.event, bound)\r\n      }\r\n    }\r\n  }\r\n\r\n  unregisterEventListeners(ext: object) {\r\n    const listeners = this.getComponentsWithType<ListenerComponent>(ext, ListenerComponent)\r\n\r\n    for (const listener of listeners) {\r\n      const emitter = this.emitters.get(listener.options.emitter)\r\n      const bound = Reflect.getMetadata('bound', listener)\r\n\r\n      if (emitter && bound) {\r\n        emitter.removeListener(listener.options.event, bound)\r\n      }\r\n    }\r\n  }\r\n\r\n  async loadAllModulesInDirectory(dir: string, pattern?: RegExp): Promise<object[]> {\r\n    const results: object[] = []\r\n\r\n    const files = walkSync(dir).filter((x) => (x.endsWith('.ts') || x.endsWith('.js')) && (!pattern || pattern.test(x)))\r\n\r\n    for (const file of files) {\r\n      if (file.endsWith('.d.ts')) continue\r\n      const p = path.join(dir, file)\r\n      results.push(...(await this.loadModulesAtPath(p)))\r\n    }\r\n\r\n    return results\r\n  }\r\n\r\n  async loadModulesAtPath(file: string) {\r\n    this.logger.info(`Loading module at path ${chalk.green(file)}`)\r\n\r\n    const p = require.resolve(file)\r\n\r\n    const mod = require(p)\r\n\r\n    if (typeof mod.setup !== 'function') throw new Error('Extension must have a setup function')\r\n\r\n    const modules = await mod.setup(this.client)\r\n\r\n    return this.registerModules(modules, p)\r\n  }\r\n\r\n  private async registerModules(modules: object | object[], p: string) {\r\n    const results: object[] = []\r\n    if (modules instanceof Array) {\r\n      for (const module of modules) {\r\n        await this.registerModule(module)\r\n        Reflect.defineMetadata(FilePathSymbol, p, module)\r\n        results.push(module)\r\n      }\r\n    } else {\r\n      await this.registerModule(modules)\r\n      Reflect.defineMetadata(FilePathSymbol, p, modules)\r\n      results.push(modules)\r\n    }\r\n\r\n    return results\r\n  }\r\n\r\n  async reloadModules() {\r\n    const result: { file: string; result: boolean; error?: Error; extensions?: object[] }[] = []\r\n    const paths = new Set<string>()\r\n    const extensions = [...this.extensions]\r\n    for (const module of extensions) {\r\n      const file = Reflect.getMetadata(FilePathSymbol, module)\r\n      if (!file) continue\r\n\r\n      this.logger.info(`Unloading module: ${chalk.green(module.constructor.name)}`)\r\n\r\n      paths.add(file)\r\n\r\n      await this.unregisterModule(module)\r\n\r\n      delete require.cache[require.resolve(file)]\r\n    }\r\n\r\n    for (const path of paths) {\r\n      try {\r\n        const extensions = await this.loadModulesAtPath(path)\r\n\r\n        result.push({\r\n          file: path,\r\n          result: true,\r\n          extensions,\r\n        })\r\n      } catch (e) {\r\n        result.push({\r\n          file: path,\r\n          result: false,\r\n          error: e as Error,\r\n        })\r\n      }\r\n    }\r\n\r\n    return result\r\n  }\r\n\r\n  async registerModule(ext: object) {\r\n    Reflect.defineMetadata(CommandClientSymbol, this.client, ext)\r\n\r\n    this.registerEventListeners(ext)\r\n    await this.runModuleHook(ext, 'load')\r\n    this.extensions.push(ext)\r\n    this.logger.info(`Module registered: ${chalk.green(ext.constructor.name)}`)\r\n  }\r\n\r\n  async unregisterModule(ext: object) {\r\n    this.unregisterEventListeners(ext)\r\n    await this.runModuleHook(ext, 'unload')\r\n    _.remove(this.extensions, (x) => x === ext)\r\n    this.logger.info(`Module unregistered: ${chalk.green(ext.constructor.name)}`)\r\n  }\r\n\r\n  runModuleHook(ext: object, hookName: string, ...args: unknown[]) {\r\n    const hooks = getModuleHookStore(ext)\r\n\r\n    const functions = hooks.get(hookName)\r\n\r\n    if (functions) {\r\n      for (const fn of functions) {\r\n        fn.call(ext, ...args)\r\n      }\r\n    }\r\n  }\r\n\r\n  registerEventEmitter(name: string, emitter: EventEmitter) {\r\n    this.emitters.set(name, emitter)\r\n  }\r\n}\r\n","/*\r\n* File: index.ts\r\n* \r\n* Copyright (c) 2022-2022 pikokr\r\n* \r\n* Licensed under MIT License. Please see more defails in LICENSE file.\r\n*/\r\n\r\nexport * from './Registry'\nexport * from './CommandClient'\n","/*\r\n * File: Extension.ts\r\n *\r\n * Copyright (c) 2022-2022 pikokr\r\n *\r\n * Licensed under MIT License. Please see more defails in LICENSE file.\r\n */\r\n\r\nimport chalk from 'chalk'\r\nimport { Collection } from 'discord.js'\r\nimport { Logger } from 'tslog'\r\nimport { ComponentArgument } from '../components/ComponentArgument'\r\nimport { ConverterComponent } from '../converter'\r\nimport { CommandClient } from '../structures'\r\n\r\nexport class Extension {\r\n  protected get commandClient() {\r\n    return CommandClient.getFromModule(this)\r\n  }\r\n\r\n  protected get client() {\r\n    return this.commandClient.discord\r\n  }\r\n\r\n  protected _logger?: Logger<unknown>\r\n\r\n  protected get logger() {\r\n    if (!this._logger) this._logger = this.commandClient.logger.getSubLogger({ prefix: [chalk.green(`[${this.constructor.name}]`)] })\r\n    return this._logger\r\n  }\r\n\r\n  protected async convertArguments(\r\n    component: unknown,\r\n    argList: unknown[],\r\n    args: Collection<number, ComponentArgument>,\r\n    getConverterArgs: (arg: ComponentArgument, index: number, converter: ConverterComponent) => unknown[] | Promise<unknown[]>,\r\n  ) {\r\n    const items = new Collection<unknown, { ext: object; component: ConverterComponent }>()\r\n\r\n    for (const extension of this.commandClient.registry.extensions) {\r\n      for (const converter of this.commandClient.registry.getComponentsWithType<ConverterComponent>(extension, ConverterComponent)) {\r\n        if (converter.options.component != component) continue\r\n\r\n        items.set(converter.options.type, { component: converter, ext: extension })\r\n      }\r\n    }\r\n\r\n    for (const [index, arg] of args) {\r\n      const converter = items.get(arg.type)\r\n\r\n      if (!converter) {\r\n        argList[index] = undefined\r\n        continue\r\n      }\r\n\r\n      const converterArgs = await getConverterArgs(arg, index, converter.component)\r\n\r\n      argList[index] = await converter.component.execute(converter.ext, converterArgs)\r\n    }\r\n  }\r\n}\r\n","/*\r\n * File: CTSExtension.ts\r\n *\r\n * Copyright (c) 2022-2022 pikokr\r\n *\r\n * Licensed under MIT License. Please see more defails in LICENSE file.\r\n */\r\n\r\nimport chalk from 'chalk'\r\nimport { Extension } from './Extension'\r\n\r\nexport class CTSExtension extends Extension {\r\n  protected get logger() {\r\n    if (!this._logger) this._logger = this.commandClient.ctsLogger.getSubLogger({ prefix: [chalk.green(`[${this.constructor.name}]`)] })\r\n    return this._logger\r\n  }\r\n}\r\n","/*\r\n * File: ApplicationCommandExtension.ts\r\n *\r\n * Copyright (c) 2022-2022 pikokr\r\n *\r\n * Licensed under MIT License. Please see more defails in LICENSE file.\r\n */\r\n\r\nimport chalk from 'chalk'\r\nimport {\r\n  APIApplicationCommandSubcommandGroupOption,\r\n  APIApplicationCommandSubcommandOption,\r\n  ApplicationCommandData,\r\n  ApplicationCommandDataResolvable,\r\n  ApplicationCommandOptionType,\r\n  ApplicationCommandSubCommandData,\r\n  ApplicationCommandType,\r\n  ChatInputApplicationCommandData,\r\n  ChatInputCommandInteraction,\r\n  Collection,\r\n  CommandInteraction,\r\n  Interaction,\r\n  InteractionType,\r\n  MessageContextMenuCommandInteraction,\r\n  Snowflake,\r\n  UserContextMenuCommandInteraction,\r\n} from 'discord.js'\r\nimport { ApplicationCommandComponent } from './ApplicationCommand'\r\nimport { ApplicationCommandOption } from './ApplicationCommandOption'\r\nimport { listener } from '../core/listener'\r\nimport { argConverter } from '../core/converter'\r\nimport { CTSExtension } from '../core/extensions/CTSExtension'\r\n\r\nexport type ApplicationCommandExtensionConfig = {\r\n  guilds?: Snowflake[]\r\n}\r\n\r\nexport class ApplicationCommandExtension extends CTSExtension {\r\n  constructor(public config: ApplicationCommandExtensionConfig) {\r\n    super()\r\n  }\r\n\r\n  unmanagedCommands: (ApplicationCommandData & { guilds?: Snowflake[] })[] = []\r\n\r\n  registerUnmanagedCommand(command: ApplicationCommandData & { guilds?: Snowflake[] }) {\r\n    this.unmanagedCommands.push(command)\r\n  }\r\n\r\n  @listener({ event: 'interactionCreate' })\r\n  async interactionCreate(i: Interaction) {\r\n    try {\r\n      if (i.type !== InteractionType.ApplicationCommand) return\r\n\r\n      let cmd: ApplicationCommandComponent | null = null\r\n      let ext: object | null = null\r\n\r\n      const extensions = this.commandClient.registry.extensions\r\n\r\n      let subcommand: string | null = null\r\n      let subcommandGroup: string | null = null\r\n\r\n      if (i.commandType === ApplicationCommandType.ChatInput) {\r\n        subcommand = i.options.getSubcommand(false)\r\n        subcommandGroup = i.options.getSubcommandGroup(false)\r\n      }\r\n\r\n      extLoop: for (const extension of extensions) {\r\n        const components = this.commandClient.registry.getComponentsWithType<ApplicationCommandComponent>(extension, ApplicationCommandComponent)\r\n\r\n        if (subcommand) {\r\n          for (const command of components) {\r\n            if (!command.subcommandGroup && !command.subcommandGroupChild) continue\r\n\r\n            if (\r\n              command.subcommandGroupChild &&\r\n              command.subcommandGroupChild.parent.options.name === i.commandName &&\r\n              command.subcommandGroupChild.options.name === subcommandGroup &&\r\n              command.options.name === subcommand\r\n            ) {\r\n              ext = extension\r\n              cmd = command\r\n              break extLoop\r\n            }\r\n            if (command.subcommandGroup && !subcommandGroup && command.subcommandGroup.options.name === i.commandName && command.options.name === subcommand) {\r\n              ext = extension\r\n              cmd = command\r\n              break extLoop\r\n            }\r\n          }\r\n        } else {\r\n          for (const command of components) {\r\n            if (command.options.name === i.commandName) {\r\n              ext = extension\r\n              cmd = command\r\n              break extLoop\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n      if (cmd && ext) {\r\n        const argList: unknown[] = []\r\n\r\n        await this.convertArguments(ApplicationCommandComponent, argList, cmd.argTypes, () => [i])\r\n\r\n        for (const [idx, arg] of cmd.argTypes) {\r\n          let value: unknown = null\r\n\r\n          for (const decorator of arg.decorators) {\r\n            if (decorator instanceof ApplicationCommandOption) {\r\n              if ([ApplicationCommandOptionType.Subcommand, ApplicationCommandOptionType.SubcommandGroup].includes(decorator.options.type) && i.isChatInputCommand()) {\r\n                if (decorator.options.type === ApplicationCommandOptionType.Subcommand) {\r\n                  value = i.options.getSubcommand() === decorator.options.name\r\n                  break\r\n                }\r\n                if (decorator.options.type === ApplicationCommandOptionType.SubcommandGroup) {\r\n                  value = i.options.getSubcommandGroup() === decorator.options.name\r\n                  break\r\n                }\r\n              }\r\n\r\n              value = i.options.get(decorator.options.name, false)?.value\r\n              break\r\n            }\r\n          }\r\n\r\n          if (value) {\r\n            argList[idx] = value\r\n          }\r\n        }\r\n\r\n        try {\r\n          await cmd.executeGlobalHook(ext, 'beforeApplicationCommandCall', [i])\r\n          await cmd.execute(ext, argList, [i])\r\n        } finally {\r\n          await cmd.executeGlobalHook(ext, 'afterApplicationCommandCall', [i])\r\n        }\r\n      }\r\n    } catch (e) {\r\n      this.commandClient.emit('applicationCommandInvokeError', e, i)\r\n    }\r\n  }\r\n\r\n  async sync() {\r\n    const client = this.commandClient\r\n\r\n    this.logger.info('Trying to sync commands...')\r\n\r\n    let commands: ApplicationCommandData[] = []\r\n\r\n    const guildCommands = new Collection<Snowflake, ApplicationCommandData[]>()\r\n\r\n    const subcommandGroups = new Collection<string, ChatInputApplicationCommandData>()\r\n\r\n    for (const command of client.registry.getComponentsWithTypeGlobal<ApplicationCommandComponent>(ApplicationCommandComponent)) {\r\n      if (command.subcommandGroup) {\r\n        let group = subcommandGroups.get(command.subcommandGroup.options.name)\r\n\r\n        if (!group) {\r\n          group = {\r\n            ...command.subcommandGroup.options,\r\n            type: ApplicationCommandType.ChatInput,\r\n          }\r\n\r\n          if (command.subcommandGroup.guilds) {\r\n            for (const guild of command.subcommandGroup.guilds) {\r\n              let commands = guildCommands.get(guild)\r\n              if (!commands) {\r\n                commands = []\r\n                guildCommands.set(guild, commands)\r\n              }\r\n            }\r\n          } else {\r\n            commands.push(group)\r\n          }\r\n\r\n          subcommandGroups.set(command.subcommandGroup.options.name, group)\r\n        }\r\n\r\n        if (!group.options) group.options = []\r\n\r\n        const options = []\r\n\r\n        for (const [, arg] of command.argTypes) {\r\n          const option = arg.decorators.find((x) => x.constructor === ApplicationCommandOption) as ApplicationCommandOption\r\n\r\n          if (option) {\r\n            options.push(option.options)\r\n          }\r\n        }\r\n\r\n        group.options.push({ ...command.options, type: ApplicationCommandOptionType.Subcommand, options } as ApplicationCommandSubCommandData)\r\n\r\n        continue\r\n      } else if (command.subcommandGroupChild) {\r\n        const parent = command.subcommandGroupChild.parent\r\n        let group = subcommandGroups.get(parent.options.name)\r\n\r\n        if (!group) {\r\n          group = {\r\n            ...parent.options,\r\n            type: ApplicationCommandType.ChatInput,\r\n          }\r\n\r\n          if (parent.guilds) {\r\n            for (const guild of parent.guilds) {\r\n              let commands = guildCommands.get(guild)\r\n              if (!commands) {\r\n                commands = []\r\n                guildCommands.set(guild, commands)\r\n              }\r\n            }\r\n          } else {\r\n            commands.push(group)\r\n          }\r\n\r\n          subcommandGroups.set(parent.options.name, group)\r\n        }\r\n\r\n        if (!group.options) group.options = []\r\n\r\n        let child = group.options.find((x) => x.name === command.subcommandGroupChild!.options.name) as APIApplicationCommandSubcommandGroupOption\r\n\r\n        if (!child) {\r\n          child = { type: ApplicationCommandOptionType.SubcommandGroup, ...(command.subcommandGroupChild.options as Omit<APIApplicationCommandSubcommandGroupOption, 'type'>) }\r\n          group.options.push(child)\r\n        }\r\n\r\n        if (!child.options) child.options = []\r\n\r\n        const options = []\r\n\r\n        for (const [, arg] of command.argTypes) {\r\n          const option = arg.decorators.find((x) => x.constructor === ApplicationCommandOption) as ApplicationCommandOption\r\n\r\n          if (option) {\r\n            options.push(option.options)\r\n          }\r\n        }\r\n\r\n        child.options.push({ ...command.options, type: ApplicationCommandOptionType.Subcommand, options } as APIApplicationCommandSubcommandOption)\r\n\r\n        continue\r\n      }\r\n\r\n      const cmd: ApplicationCommandData = { ...command.options }\r\n\r\n      if (cmd.type === ApplicationCommandType.ChatInput) {\r\n        cmd.options = []\r\n\r\n        for (const [, arg] of command.argTypes) {\r\n          const option = arg.decorators.find((x) => x.constructor === ApplicationCommandOption) as ApplicationCommandOption\r\n\r\n          if (option) {\r\n            cmd.options.push(option.options)\r\n          }\r\n        }\r\n      }\r\n\r\n      await command.executeHook(this, 'beforeSync', [cmd, command])\r\n\r\n      if (command.options.guilds) {\r\n        for (const guild of command.options.guilds) {\r\n          let commands = guildCommands.get(guild)\r\n          if (!commands) {\r\n            commands = []\r\n            guildCommands.set(guild, commands)\r\n          }\r\n          commands.push(cmd)\r\n        }\r\n        continue\r\n      }\r\n\r\n      commands.push(cmd)\r\n    }\r\n\r\n    for (const { guilds, ...rest } of this.unmanagedCommands) {\r\n      if (guilds) {\r\n        for (const guild of guilds) {\r\n          let commands = guildCommands.get(guild)\r\n          if (!commands) {\r\n            commands = []\r\n            guildCommands.set(guild, commands)\r\n          }\r\n          commands.push(rest)\r\n        }\r\n        continue\r\n      } else {\r\n        commands.push(rest)\r\n      }\r\n    }\r\n\r\n    if (this.config.guilds) {\r\n      for (const guild of this.config.guilds) {\r\n        let g = guildCommands.get(guild)\r\n        if (!g) {\r\n          g = []\r\n          guildCommands.set(guild, g)\r\n        }\r\n        g.push(...commands)\r\n      }\r\n\r\n      commands = []\r\n    }\r\n\r\n    if (guildCommands.size) {\r\n      for (const [guild, commands] of guildCommands) {\r\n        try {\r\n          const g = await this.client.guilds.fetch(guild)\r\n          await g.fetch()\r\n          this.logger.info(\r\n            `Processing ${chalk.green(commands.length)} commands(${commands.map((x) => chalk.blue(x.name)).join(', ')}) for guild ${chalk.green(g.name)}(${chalk.blue(g.id)})`,\r\n          )\r\n\r\n          await g.commands.set(commands)\r\n\r\n          this.logger.info(`Successfully registered commands for guild ${chalk.green(g.name)}(${chalk.blue(g.id)})`)\r\n        } catch (e) {\r\n          this.logger.error(`Failed to register commands to guild ${chalk.green(guild)}: ${(e as Error).message}`)\r\n        }\r\n      }\r\n    }\r\n    if (commands.length) {\r\n      try {\r\n        this.logger.info(`Processing ${chalk.green(commands.length)} commands(${commands.map((x) => chalk.blue(x.name)).join(', ')}) for application scope...`)\r\n\r\n        await this.client.application!.commands.set(commands)\r\n\r\n        this.logger.info('Successfully registered commands.')\r\n      } catch (e) {\r\n        this.logger.error(`Failed to register commands to global: ${(e as Error).message}`)\r\n      }\r\n    }\r\n  }\r\n\r\n  @argConverter({\r\n    component: ApplicationCommandComponent,\r\n    parameterless: true,\r\n    type: ChatInputCommandInteraction,\r\n  })\r\n  async chatInteraction(i: ChatInputCommandInteraction) {\r\n    return i\r\n  }\r\n\r\n  @argConverter({\r\n    component: ApplicationCommandComponent,\r\n    parameterless: true,\r\n    type: MessageContextMenuCommandInteraction,\r\n  })\r\n  async messageInteraction(i: MessageContextMenuCommandInteraction) {\r\n    return i\r\n  }\r\n\r\n  @argConverter({\r\n    component: ApplicationCommandComponent,\r\n    parameterless: true,\r\n    type: UserContextMenuCommandInteraction,\r\n  })\r\n  async userInteraction(i: UserContextMenuCommandInteraction) {\r\n    return i\r\n  }\r\n\r\n  @argConverter({\r\n    component: ApplicationCommandComponent,\r\n    parameterless: true,\r\n    type: CommandInteraction,\r\n  })\r\n  async commandInteraction(i: UserContextMenuCommandInteraction) {\r\n    return i\r\n  }\r\n}\r\n","/*\r\n * File: TextCommand.ts\r\n *\r\n * Copyright (c) 2022-2022 pikokr\r\n *\r\n * Licensed under MIT License. Please see more defails in LICENSE file.\r\n */\r\n\r\nimport { createComponentDecorator } from '../core/components/decoratorCreator'\r\nimport { BaseComponent } from '../core/components/BaseComponent'\r\n\r\nexport type TextCommandOptions = {\r\n  name: string\r\n  aliases?: string[]\r\n  description?: string\r\n}\r\n\r\nexport class TextCommandComponent extends BaseComponent {\r\n  constructor(public options: TextCommandOptions) {\r\n    super()\r\n  }\r\n}\r\n\r\nexport const command = (options: TextCommandOptions) => createComponentDecorator(new TextCommandComponent(options))\r\n","/*\r\n * File: parameters.ts\r\n *\r\n * Copyright (c) 2022-2022 pikokr\r\n *\r\n * Licensed under MIT License. Please see more defails in LICENSE file.\r\n */\r\n\r\nimport { ComponentArgumentDecorator } from '../core'\r\nimport { createArgumentDecorator } from '../core'\r\n\r\nexport class TextCommandRestOption extends ComponentArgumentDecorator<void> {}\r\n\r\nexport const rest = createArgumentDecorator(TextCommandRestOption)\r\n","/*\r\n * File: TextCommandExtension.ts\r\n *\r\n * Copyright (c) 2022-2022 pikokr\r\n *\r\n * Licensed under MIT License. Please see more defails in LICENSE file.\r\n */\r\n\r\nimport { listener } from '../core/listener'\r\nimport { Message } from 'discord.js'\r\nimport { CTSExtension } from '../core/extensions/CTSExtension'\r\nimport { TextCommandComponent } from './TextCommand'\r\nimport { TextCommandRestOption } from './parameters'\r\nimport { argConverter } from '../core'\r\n\r\nexport type TextCommandConfig = {\r\n  prefix:\r\n    | string\r\n    | string[]\r\n    | ((msg: Message) => Promise<string | string[]> | string | string[])\r\n}\r\n\r\ndeclare module 'discord.js' {\r\n  interface Message {\r\n    command: TextCommandComponent\r\n  }\r\n}\r\n\r\nexport class TextCommandExtension extends CTSExtension {\r\n  constructor(private config: TextCommandConfig) {\r\n    super()\r\n  }\r\n\r\n  private async processPrefix(msg: Message): Promise<number | null> {\r\n    const content = msg.content\r\n    let prefix = this.config.prefix\r\n\r\n    if (typeof prefix === 'function') {\r\n      prefix = await prefix(msg)\r\n    }\r\n\r\n    if (typeof prefix === 'string') {\r\n      if (content.startsWith(prefix)) return prefix.length\r\n      return null\r\n    }\r\n\r\n    if (prefix instanceof Array) {\r\n      const p = prefix.find((x) => content.startsWith(x))\r\n\r\n      if (p) return p.length\r\n      return null\r\n    }\r\n\r\n    return null\r\n  }\r\n\r\n  @listener({ event: 'messageCreate', emitter: 'discord' })\r\n  private async messageCreate(msg: Message) {\r\n    try {\r\n      const startIndex = await this.processPrefix(msg)\r\n\r\n      if (startIndex === null) return\r\n\r\n      const content = msg.content.slice(startIndex)\r\n\r\n      const commands: TextCommandComponent[] = []\r\n\r\n      const extensions = new Map<TextCommandComponent, object>()\r\n\r\n      for (const ext of this.commandClient.registry.extensions) {\r\n        for (const cmd of this.commandClient.registry.getComponentsWithType<TextCommandComponent>(\r\n          ext,\r\n          TextCommandComponent\r\n        )) {\r\n          commands.push(cmd)\r\n          extensions.set(cmd, ext)\r\n        }\r\n      }\r\n\r\n      let commandNameLength = 0\r\n\r\n      const command = commands.find((x) => {\r\n        const names = [x.options.name]\r\n\r\n        if (x.options.aliases) {\r\n          names.push(...x.options.aliases)\r\n        }\r\n\r\n        for (const name of names) {\r\n          if (content.startsWith(name)) {\r\n            if (content.length === name.length) {\r\n              commandNameLength = name.length\r\n              return true\r\n            }\r\n            commandNameLength = name.length\r\n            return content.startsWith(name + ' ')\r\n          }\r\n        }\r\n\r\n        return false\r\n      })\r\n\r\n      if (!command) return\r\n\r\n      const ext = extensions.get(command)\r\n\r\n      if (!ext) return\r\n\r\n      msg.command = command\r\n\r\n      const args: unknown[] = []\r\n\r\n      let argStrings = content.slice(commandNameLength + 1).split(/ /g)\r\n\r\n      await this.convertArguments(\r\n        TextCommandComponent,\r\n        args,\r\n        command.argTypes,\r\n        async (arg, i, converter) => {\r\n          if (converter.options.parameterless) return [msg]\r\n\r\n          if (\r\n            arg.decorators.find((x) => x.constructor === TextCommandRestOption)\r\n          ) {\r\n            const text = argStrings.join(' ')\r\n            argStrings = []\r\n            return [text, msg]\r\n          }\r\n          return [argStrings.shift(), msg]\r\n        }\r\n      )\r\n\r\n      await command.execute(ext, args, [msg])\r\n    } catch (e) {\r\n      this.commandClient.emit('textCommandInvokeError', e, msg)\r\n    }\r\n  }\r\n\r\n  @argConverter({\r\n    component: TextCommandComponent,\r\n    type: Message,\r\n    parameterless: true,\r\n  })\r\n  async mesage(msg: Message) {\r\n    return msg\r\n  }\r\n\r\n  @argConverter({ component: TextCommandComponent, type: String })\r\n  async str(value: string) {\r\n    return value\r\n  }\r\n\r\n  @argConverter({ component: TextCommandComponent, type: Number })\r\n  async num(value: string) {\r\n    return Number(value)\r\n  }\r\n}\r\n","/*\r\n * File: CommandClient.ts\r\n *\r\n * Copyright (c) 2022-2022 pikokr\r\n *\r\n * Licensed under MIT License. Please see more defails in LICENSE file.\r\n */\r\n\r\nimport chalk from 'chalk'\r\nimport { Client, Snowflake, Team, User } from 'discord.js'\r\nimport EventEmitter from 'events'\r\nimport { ISettingsParam, Logger } from 'tslog'\r\nimport { ApplicationCommandExtension, ApplicationCommandExtensionConfig } from '../../applicationCommand/ApplicationCommandExtension'\r\nimport { TextCommandConfig } from '../../textCommand'\r\nimport { TextCommandExtension } from '../../textCommand/TextCommandExtension'\r\nimport { CommandClientSymbol } from '../symbols'\r\nimport { Registry } from './Registry'\r\nexport class CommandClient extends EventEmitter {\r\n  ctsLogger: Logger<unknown>\r\n  registry: Registry\r\n\r\n  owners: Set<Snowflake> = new Set()\r\n\r\n  constructor(public discord: Client, public logger: Logger<unknown> = new Logger({ prettyLogTimeZone: 'local' }), loggerOptions: ISettingsParam<unknown> = {}) {\r\n    super()\r\n\r\n    this.ctsLogger = logger.getSubLogger({ prefix: [chalk.blue('[command.ts]')], ...loggerOptions })\r\n\r\n    this.registry = new Registry(this.ctsLogger, this)\r\n\r\n    this.registry.registerEventEmitter('cts', this)\r\n    this.registry.registerEventEmitter('discord', this.discord)\r\n  }\r\n\r\n  async isOwner(user: User): Promise<boolean> {\r\n    return this.owners.has(user.id)\r\n  }\r\n\r\n  async fetchOwners() {\r\n    if (!this.discord.application) throw new Error('The client is not logged in.')\r\n\r\n    this.ctsLogger.info('Fetching owners...')\r\n\r\n    await this.discord.application.fetch()\r\n\r\n    const owner = this.discord.application.owner\r\n\r\n    if (!owner) throw new Error('Cannot find application owner')\r\n\r\n    const owners: string[] = []\r\n\r\n    if (owner instanceof User) {\r\n      this.owners.add(owner.id)\r\n      owners.push(owner.tag)\r\n    } else if (owner instanceof Team) {\r\n      for (const [id, member] of owner.members) {\r\n        this.owners.add(id)\r\n        owners.push(member.user.tag)\r\n      }\r\n    }\r\n\r\n    this.ctsLogger.info(`Fetched ${chalk.green(owners.length)} owners(${owners.map((x) => chalk.blue(x)).join(', ')})`)\r\n  }\r\n\r\n  async enableApplicationCommandsExtension(config: ApplicationCommandExtensionConfig) {\r\n    await this.registry.registerModule(new ApplicationCommandExtension(config))\r\n    this.ctsLogger.info('Application command extension enabled.')\r\n  }\r\n\r\n  async enableTextCommandsExtension(config: TextCommandConfig) {\r\n    await this.registry.registerModule(new TextCommandExtension(config))\r\n    this.ctsLogger.info('Text command extension enabled.')\r\n  }\r\n\r\n  getApplicationCommandsExtension() {\r\n    return this.registry.extensions.find((x) => x.constructor === ApplicationCommandExtension) as ApplicationCommandExtension | undefined\r\n  }\r\n\r\n  static getFromModule(ext: object): CommandClient {\r\n    return Reflect.getMetadata(CommandClientSymbol, ext)\r\n  }\r\n}\r\n","/*\r\n * File: BaseComponent.ts\r\n *\r\n * Copyright (c) 2022-2022 pikokr\r\n *\r\n * Licensed under MIT License. Please see more defails in LICENSE file.\r\n */\r\n\r\nimport { Collection } from 'discord.js'\r\nimport _ from 'lodash'\r\nimport type { ComponentHookStore } from '../hooks'\r\nimport { ComponentArgument } from './ComponentArgument'\r\n\r\nexport class BaseComponent {\r\n  method!: Function\r\n\r\n  hooks: ComponentHookStore = new Collection()\r\n\r\n  argTypes: Collection<number, ComponentArgument> = new Collection()\r\n\r\n  _init(method: Function, argTypes: unknown[]) {\r\n    this.method = method\r\n    for (let i = 0; i < argTypes.length; i++) {\r\n      const element = argTypes[i]\r\n      this.argTypes.set(i, new ComponentArgument(element))\r\n    }\r\n  }\r\n\r\n  async executeGlobalHook(target: object, name: string, args: unknown[]) {\r\n    const { CommandClient } = await import('../structures/CommandClient')\r\n\r\n    const client = CommandClient.getFromModule(target)\r\n\r\n    const globalHooks = client.registry.globalHooks[name]\r\n\r\n    if (globalHooks) {\r\n      for (const fn of globalHooks) {\r\n        await fn.call(null, client, ...args)\r\n      }\r\n    }\r\n  }\r\n\r\n  async executeHook(target: object, name: string, args: unknown[]) {\r\n    const hook = this.hooks.get(name)\r\n\r\n    if (!hook) return\r\n\r\n    const { CommandClient } = await import('../structures/CommandClient')\r\n\r\n    const client = CommandClient.getFromModule(target)\r\n\r\n    const globalHooks = client.registry.globalHooks[name]\r\n\r\n    if (globalHooks) {\r\n      hook.unshift(...globalHooks)\r\n    }\r\n\r\n    for (const fn of hook) {\r\n      await fn.call(null, client, ...args)\r\n    }\r\n  }\r\n\r\n  async execute(target: object, args: unknown[], beforeCallArgs: unknown[] = args) {\r\n    await this.executeHook(target, 'beforeCall', beforeCallArgs)\r\n    let result\r\n    try {\r\n      result = await this.method.call(target, ...args)\r\n      await this.executeHook(target, 'afterCall', [...beforeCallArgs, result])\r\n    } catch (e) {\r\n      await this.executeHook(target, 'invokeError', [e, ...beforeCallArgs])\r\n      throw e\r\n    }\r\n\r\n    return result\r\n  }\r\n}\r\n","/*\r\n* File: index.ts\r\n* \r\n* Copyright (c) 2022-2022 pikokr\r\n* \r\n* Licensed under MIT License. Please see more defails in LICENSE file.\r\n*/\r\n\r\nimport 'reflect-metadata'\r\nexport * from './decoratorCreator'\r\nexport * from './ComponentArgument'\r\nexport * from './ComponentArgumentDecorator'\r\nexport * from './BaseComponent'\r\n","/*\r\n* File: errors.ts\r\n* \r\n* Copyright (c) 2022-2022 pikokr\r\n* \r\n* Licensed under MIT License. Please see more defails in LICENSE file.\r\n*/\r\n\r\nexport class OwnerOnlyError {}\n","/*\r\n * File: checks.ts\r\n *\r\n * Copyright (c) 2022-2022 pikokr\r\n *\r\n * Licensed under MIT License. Please see more defails in LICENSE file.\r\n */\r\n\r\nimport { BaseInteraction, Interaction, Message } from 'discord.js'\r\nimport { createComponentHook } from '../hooks'\r\nimport { ComponentHookFn } from '../hooks/componentHook'\r\nimport { CommandClient } from '../structures'\r\nimport { OwnerOnlyError } from './errors'\r\n\r\nexport const createCheckDecorator = (fn: ComponentHookFn) => createComponentHook('beforeCall', fn)\r\n\r\nexport const ownerOnly = createCheckDecorator(async (client: CommandClient, i: Interaction | Message) => {\r\n  let isOwner = false\r\n\r\n  if (i instanceof BaseInteraction) {\r\n    client\r\n    isOwner = await client.isOwner(i.user)\r\n  } else if (i instanceof Message) {\r\n    isOwner = await client.isOwner(i.author)\r\n  }\r\n\r\n  if (!isOwner) throw new OwnerOnlyError()\r\n})\r\n","export const mergeMethodDecorators = (decorators: MethodDecorator[]): MethodDecorator => {\r\n  return (target, key, descriptor) => {\r\n    for (const decorator of decorators) {\r\n      decorator(target, key, descriptor)\r\n    }\r\n  }\r\n}\r\n","/*\r\n * File: index.ts\r\n *\r\n * Copyright (c) 2022-2022 pikokr\r\n *\r\n * Licensed under MIT License. Please see more defails in LICENSE file.\r\n */\r\n\r\nexport * from './checks'\r\nexport * from './errors'\r\nexport * from './decorators'\r\n","/*\r\n* File: index.ts\r\n* \r\n* Copyright (c) 2022-2022 pikokr\r\n* \r\n* Licensed under MIT License. Please see more defails in LICENSE file.\r\n*/\r\n\r\nexport * from './Extension'\n","/*\r\n* File: index.ts\r\n* \r\n* Copyright (c) 2022-2022 pikokr\r\n* \r\n* Licensed under MIT License. Please see more defails in LICENSE file.\r\n*/\r\n\r\nexport * from './components'\nexport * from './hooks'\nexport * from './converter'\nexport * from './utils'\nexport * from './listener'\nexport * from './structures'\nexport * from './extensions'\n","/*\r\n* File: index.ts\r\n* \r\n* Copyright (c) 2022-2022 pikokr\r\n* \r\n* Licensed under MIT License. Please see more defails in LICENSE file.\r\n*/\r\n\r\nexport * from './core'\r\nexport * from './applicationCommand'\r\nexport * from './textCommand'\r\n","import { APIApplicationCommandSubcommandOption, ApplicationCommandType, ChatInputApplicationCommandData } from 'discord.js'\r\nimport { createComponentDecorator } from '../core'\r\nimport { ApplicationCommandComponent } from './ApplicationCommand'\r\n\r\nexport class SubCommandGroup {\r\n  constructor(public options: Omit<APIApplicationCommandSubcommandOption, 'type'>, public guilds?: string[]) {}\r\n\r\n  command(options: Omit<ChatInputApplicationCommandData, 'options' | 'type'>): MethodDecorator {\r\n    const cmd = new ApplicationCommandComponent({\r\n      type: ApplicationCommandType.ChatInput,\r\n      ...options,\r\n    })\r\n    cmd.subcommandGroup = this\r\n    return createComponentDecorator(cmd)\r\n  }\r\n\r\n  createChild(options: Omit<APIApplicationCommandSubcommandOption, 'type'>) {\r\n    return new SubCommandGroupChild(options, this)\r\n  }\r\n}\r\n\r\nexport class SubCommandGroupChild {\r\n  constructor(public options: Omit<APIApplicationCommandSubcommandOption, 'type'>, public parent: SubCommandGroup) {}\r\n\r\n  command(options: Omit<ChatInputApplicationCommandData, 'options' | 'type'>): MethodDecorator {\r\n    const cmd = new ApplicationCommandComponent({\r\n      type: ApplicationCommandType.ChatInput,\r\n      ...options,\r\n    })\r\n    cmd.subcommandGroupChild = this\r\n    return createComponentDecorator(cmd)\r\n  }\r\n}\r\n"],"mappings":"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","names":[]}